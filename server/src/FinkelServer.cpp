// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "Finkel.h"
#include <protocol/TBinaryProtocol.h>
#include <server/TSimpleServer.h>
#include <tchar.h>
#include <transport/TServerSocket.h>
#include <transport/TBufferTransports.h>
#include <ThriftWin32.h>
// TODO(gareth): Why does it break things to include this first?
#include "Camera.h"

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

#define MTGO "C:\\Program Files (x86)\\Wizards of the Coast\\Magic Online\\Kicker.exe"
#define MTGO_PATH "C:\\Program Files (x86)\\Wizards of the Coast\\Magic Online"


class FinkelHandler : virtual public FinkelIf {
public:
  /**
   * Whether or not MTGO is running.
   */
  bool running;

  /**
   * Whether or not we're in the MTGO kicker.
   */
  bool kicker;

  /**
   * A camera to take screenshots of MTGO.
   */
  Camera *camera;

  FinkelHandler() {
    OutputDebugString(TEXT("Bringing up Finkel Service"));
    this->running = false;
    this->kicker = false;
    this->camera = new Camera();
  }

  bool Start(const std::string& username, const std::string& password) {
    if (this->running) {
      return false;
    }

    // Shell out to MTGO
    LPTSTR program = _tcsdup(TEXT(MTGO));
    LPTSTR path = _tcsdup(TEXT(MTGO_PATH));
    PROCESS_INFORMATION procInfo;
    STARTUPINFO startupInfo;
    ZeroMemory(&startupInfo,sizeof(STARTUPINFO));
    startupInfo.cb = sizeof(STARTUPINFO);
    startupInfo.dwFlags = STARTF_USESTDHANDLES;

    bool created = CreateProcess(
      program /** lpApplicationName */,
      NULL /** lpCommandLine */,
      NULL /** lpProcessAttributes */,
      NULL /** lpThreadAttributes */,
      false /** bInheritHandles */,
      CREATE_NEW_CONSOLE /** dwCreationFlags */,
      NULL /** lpEnvironment */,
      path /** lpCurrentDirectory */,
      &startupInfo,
      &procInfo
    );

    if (!created) {
      return false;
    }

    this->kicker = true;

    // Wait for the kicker to come up.
    HWND windowHandle = this->_GetWindow();
    while (windowHandle == NULL) {
      OutputDebugString(TEXT("Waiting for Kicker..."));
      Sleep(1000);
      windowHandle = this->_GetWindow();
    }

    // If there is an update available, get it.
    // TODO(gareth)

    // Launch MTGO.

    // Sign in with the username and password.

    this->running = true;
    return true;
  }

  bool Stop() {
    OutputDebugString(TEXT("Stop"));
    if (!this->running) {
      return false;
    }

    // Kill Magic Online
    CloseWindow(this->_GetWindow());

    this->running = false;
    return true;
  }

  void TakeScreenshot(std::vector<std::vector<int8_t>> & _return) {
    OutputDebugString(TEXT("TakeScreenshot"));
    this->camera->TakeScreenshot(this->_GetWindow(), _return);
  }

  bool ProcessUserInput(const std::vector<UserInput> & inputSequence) {
    // TODO(gareth): Implement this.
    OutputDebugString(TEXT("ProcessUserInput"));
    return false;
  }

  HWND _GetWindow() {
    return FindWindow(
      NULL,
      TEXT("Magic Online 3.0")
    );
  }
};

int main(int argc, char **argv) {
  int port = 9090;
  shared_ptr<FinkelHandler> handler(new FinkelHandler());
  shared_ptr<TProcessor> processor(new FinkelProcessor(handler));
  shared_ptr<TTransportFactory> transportFactory(
    new TBufferedTransportFactory()
  );
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  ThriftWin32EventManager eventMgr;
  shared_ptr<TNonblockingServer> server =
    eventMgr.createNonblockingServer(processor, protocolFactory, port);
  server->serve();

  return 0;
}
